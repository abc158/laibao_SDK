###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        20/Oct/2017  19:00:17
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\1708\SDK - unlock\src\ui-manager\test_cmd_handle.c
#    Command line =  
#        "F:\1708\SDK - unlock\src\ui-manager\test_cmd_handle.c" -lcN
#        "F:\1708\SDK - unlock\project\Debug\List\" --diag_error PE223 -o
#        "F:\1708\SDK - unlock\project\Debug\Obj\" --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" --preinclude "F:\1708\SDK -
#        unlock\project\..\lib\syscall_api.h" -I "F:\1708\SDK -
#        unlock\project\..\includes\" -I "F:\1708\SDK -
#        unlock\project\..\src\includes\" -I "F:\1708\SDK -
#        unlock\project\..\lib\" -I "F:\1708\SDK - unlock\project\..\src\" -I
#        "F:\1708\SDK - unlock\project\..\src\local_process\" -I "F:\1708\SDK -
#        unlock\project\..\src\cfg\" -I "F:\1708\SDK -
#        unlock\project\..\src\dock\" -I "F:\1708\SDK -
#        unlock\project\..\src\guardrail\" -I "F:\1708\SDK -
#        unlock\project\..\src\wireless\" -Ohz
#    List file    =  
#        F:\1708\SDK - unlock\project\Debug\List\test_cmd_handle.lst
#    Object file  =  F:\1708\SDK - unlock\project\Debug\Obj\test_cmd_handle.o
#
###############################################################################

F:\1708\SDK - unlock\src\ui-manager\test_cmd_handle.c
      1          #include "stdio.h"
      2          #include "stdlib.h"
      3          #include "string.h"
      4          #include "am_type.h"
      5          #include "am_robot_type.h"
      6          #include "syscall_api.h"
      7          #include "ui-test_cmd_handle.h"
      8          #include "am_key.h"
      9          #include "ui-commands.h"
     10          #include "sensor/sensor.h"
     11          #include "ui-ir.h"
     12          #include "docking-new.h"
     13          #include "charge/charge.h"
     14          #include "syscall_api.h"
     15          #include "cfg/adc_chan.h"
     16          #include "sensor/sensor.h"
     17          #include "am_config_macro.h"
     18          #include "motor/robot_brush.h"
     19          #include "motor/robot_suction.h"
     20          #include "util/current.h"
     21          #include "ui-song-player.h"
     22          #include "act.h"
     23          
     24          #define  ADJ_BAT_VOL_OFFSET 0
     25          //-30 -25 -20 -15 -10 -5 0 5 10 15 20 25 30 35 40 45 50
     26          const char temp_list[]={148,117,92,71,54,42,32,25,20,15,12,10,8,6,5,4,3};
     27          
     28          /*测试项,如果测试顺序调整,改变这个数组的的测试命令顺序即可*/
     29          TEST_CMD_E test_item_table[UI_TEST_ITEM_MAX]={CMD_TEST_BUMP_DROP, CMD_TEST_CLIFF_LIGHTTOUCH,
     30          	                                            CMD_TEST_ALL_IR, CMD_BAT,
     31          	                                            CMD_TEST_ALL_CHARGE_MODE, CMD_DOCK_CURRENT,
     32          	                                            CMD_WHEEL_L_FORWARD, CMD_WHEEL_R_FORWARD,
     33          	                                            CMD_WHEEL_L_REV_SPD, CMD_WHEEL_R_REV_SPD,
     34          	                                            CMD_MAIN_FORWARD, CMD_MAIN_REV,
     35          	                                            CMD_SIDE_FORWARD, CMD_SIDE_REV,
     36          	                                            CMD_VACCUM};
     37          
     38          static volatile int self_test_result;   /*测试结果*/
     39          static BumpState bump_state;            /*碰撞状态*/
     40          static U8  wheel_test_event = 0;        /*轮子测试*/
     41          static U8  other_motor_test = 0;        /*主刷,边刷,真空测试*/
     42          static U8  cmd_stasis_test = 0;         /*是否万向轮测试*/
     43          static U16 ui_test_num_last= 0;         /*上一次的测试命令*/
     44          static U32 ui_test_last_ts = 0;         /*检测到红外的开始时间*/
     45          static U32 test_result_dly = 0;         /*检测到红外的延时*/
     46          static U32 stasis_state = 0;            /*万向轮状态*/
     47          static U8  write_nvram_flag = 0;
     48          static U32 ui_test_last_ts2[IR_DECODER_MAX] = {0};
     49          static U8  pc_test_enableq  = 0;
     50          extern TEST_CMD_E ui_test_cmd;
     51          extern void ir_test_all_result(void);
     52          extern U8 get_ir_test(IR_REMOT_POSITION_E index);
     53          extern u8 vaccum_is_maybe_stall(void);
     54          static uint16_t vac_current_over_count = 0;                 /*真空异常计数*/
     55          u8 pc_test_flag =0; 
     56          static u8 robot_is_near_hazard(u8 index)
     57          {
     58            return robot_is_cliff(index);
     59          }
     60          
     61          static u8 robot_is_near_wall(u8 index)
     62          {
     63            return robot_is_lighttouch(index);
     64          }
     65          
     66          
     67          /****************************************************************
     68          *Function   :  robot_wheel_drop_mask
     69          *Description:  判断是否轮子抬起 
     70          *Input      :  无            
     71          *Output     :  无
     72          *Return     :  轮子抬起状态
     73          *Others     :  
     74          ******************************************************************/
     75          WheelDropState robot_wheel_drop_mask(void)
     76          {
     77              WheelDropState mask = WHEEL_DROP_STATE_NONE;
     78              if (gpio_get_value(AM_IO_WHEEL_DROP_RIGHT)==0) {
     79                  mask |= WHEEL_DROP_STATE_RIGHT;
     80              }
     81              if  (gpio_get_value(AM_IO_WHEEL_DROP_LEFT)==0) {
     82                  mask |= WHEEL_DROP_STATE_LEFT;
     83              }
     84              return mask;
     85          }
     86          
     87          /****************************************************************
     88          *Function   :  robot_bump_mask
     89          *Description:  判断是否有碰撞 
     90          *Input      :  无            
     91          *Output     :  无
     92          *Return     :  碰撞状态
     93          *Others     :  
     94          ******************************************************************/
     95          BumpState robot_bump_mask(void)
     96          {
     97              BumpState mask = BUMP_MASK_NONE;
     98              if (gpio_get_value(AM_IO_BUMP_LEFT)==0) {
     99                  mask |= BUMP_FRONT_LEFT;
    100              }
    101              if  (gpio_get_value(AM_IO_BUMP_RIGHT)==0) {
    102                  mask |= BUMP_FRONT_RIGHT;
    103              }
    104             return mask;
    105          }
    106          
    107          /****************************************************************
    108          *Function   :  get_bat_temp
    109          *Description:  获取电池温度 
    110          *Input      :  无            
    111          *Output     :  无
    112          *Return     :  电池温度
    113          *Others     :  
    114          ******************************************************************/
    115          U8 get_bat_temp(void)
    116          {
    117              U8 i;
    118              U16 temp_r;
    119              temp_r = (U16)battery_temperature_get();
    120              for(i=0;i<17;i++)
    121              {
    122                  if(temp_list[i]<temp_r)
    123                      break;
    124              }
    125              if(i == 0)
    126                  i = 1;
    127              else
    128                  i = i - 1;
    129              if(i<6)
    130                  return ((-5*(6-i))+30);
    131              else
    132                  return ((5*(i-6))+30);
    133          }
    134          
    135          /****************************************************************
    136          *Function   :  handle_test_cmd
    137          *Description:  测试模式,处理每个测试项
    138          *Input      :  U32 cmd:测试命令            
    139          *Output     :  无
    140          *Return     :  无
    141          *Others     :  
    142          ******************************************************************/
    143          void handle_test_cmd(U32 cmd)
    144          {
    145              WheelDropState drop_mask ;
    146              U8 tmp_state;
    147              //S16 tmp_speed;
    148              U16 tmp_test_result;
    149              uint32_t tmp_value[2];
    150              if(cmd != ui_test_num_last)
    151              {
    152                if(wheel_test_event)
    153                {
    154                    wheel_test_event = 0;
    155                    set_motor_vels(0, 0, ACCELERATION_NON_EMERGENCY);
    156                    //stop_motor_test(WHEEL_LEFT);
    157                    //stop_motor_test(WHEEL_RIGHT);
    158                }
    159                if(other_motor_test)
    160                {
    161                    other_motor_test = 0;
    162                    //stop_motor_test(MAIN_BRUSH);
    163                    //stop_motor_test(SIDE_BRUSH);
    164                    //stop_motor_test(SUCTION);
    165                    robot_midbrush_vols_set(0);
    166                    robot_sidebrush_vols_set(0);
    167                    robot_suction_vols_set(0);
    168                }
    169                cmd_stasis_test = 0;
    170              }
    171              switch (cmd)
    172              {
    173              case CMD_TEST_WAIT:      // 0xf0000000,
    174              {
    175                  self_test_result = 0;
    176                  break;
    177              }
    178              case CMD_BUMP_L:         // 0xf0000001, /*TURE OR FALSE*/
    179              {
    180                  bump_state = get_bump_state();
    181                  self_test_result = (bump_state == BUMP_FRONT_LEFT)?1:0;
    182                  break;
    183              }
    184              case CMD_BUMP_R:         // 0xf0000002, /*TURE OR FALSE*/
    185              {
    186                  bump_state = get_bump_state();
    187                  self_test_result = (bump_state == BUMP_FRONT_RIGHT)?1:0;
    188                  break;
    189              }
    190              case CMD_BUMP_B:         // 0xf0000003, /*TURE OR FALSE*/
    191              {
    192                  bump_state = get_bump_state();
    193                  self_test_result = (bump_state == BUMP_FRONT_CENTER )?1:0;
    194                  break;
    195              }
    196              case CMD_CLIFF_L:        // 0xf0000004, /*TURE OR FALSE*/
    197              {
    198                  self_test_result = robot_is_near_hazard(CLIFF_LEFT);
    199                  break;
    200              }
    201              case CMD_CLIFF_R:        // 0xf0000005, /*TURE OR FALSE*/
    202              {
    203                  self_test_result = robot_is_near_hazard(CLIFF_RIGHT);
    204                  break;
    205              }
    206              case CMD_CLIFF_FL:       // 0xf0000006, /*TURE OR FALSE*/
    207              {
    208                  self_test_result = robot_is_near_hazard(CLIFF_FRONTLEFT);
    209                  break;
    210              }
    211              case CMD_CLIFF_FR:       // 0xf0000007, /*TURE OR FALSE*/
    212              {
    213                  self_test_result = robot_is_near_hazard(CLIFF_FRONTRIGHT);
    214                  break;
    215              }
    216              case CMD_CLIFF_RL:       // 0xf0000008, /*TURE OR FALSE*/
    217              {
    218                  self_test_result = robot_is_near_hazard(CLIFF_REAR_RIGHT);
    219                  break;
    220              }
    221              case CMD_CLIFF_RR:       // 0xf0000009, /*TURE OR FALSE*/
    222              {
    223                  self_test_result = robot_is_near_hazard(CLIFF_REAR_LEFT);
    224                  break;
    225              }
    226              case CMD_LT_L:           // 0xf000000a, /*TURE OR FALSE*/
    227              {
    228                  self_test_result = robot_is_near_wall(LT_LEFT);
    229                  break;
    230              }
    231              case CMD_LT_R:           // 0xf000000b, /*TURE OR FALSE*/
    232              {
    233                  self_test_result = robot_is_near_wall(LT_RIGHT);;
    234                  break;
    235              }
    236              case CMD_LT_CL:          // 0xf000000c, /*TURE OR FALSE*/
    237              {
    238                  self_test_result = robot_is_near_wall(LT_CENTERLEFT);
    239                  break;
    240              }
    241              case CMD_LT_CR:          // 0xf000000d, /*TURE OR FALSE*/
    242              {
    243                  self_test_result = robot_is_near_wall(LT_CENTERRIGHT);
    244                  break;
    245              }
    246              case CMD_LT_FL:          // 0xf000000e, /*TURE OR FALSE*/
    247              {
    248                  self_test_result = robot_is_near_wall(LT_FRONTLEFT);
    249                  break;
    250              }
    251              case CMD_LT_FR:          // 0xf000000f, /*TURE OR FALSE*/
    252              {
    253                  self_test_result = robot_is_near_wall(LT_FRONTRIGHT);
    254                  break;
    255              }
    256              case CMD_WHEEL_DROP_L:   // 0xf0000010, /*TURE OR FALSE*/
    257              {
    258                  drop_mask = robot_wheel_drop_mask();
    259                  if(drop_mask & WHEEL_DROP_STATE_LEFT)
    260                  {
    261                      self_test_result = 1;
    262                  }
    263                  else
    264                  {
    265                      self_test_result = 0;
    266                  }
    267                  break;
    268              }
    269              case CMD_WHEEL_DROP_R:   // 0xf0000011, /*TURE OR FALSE*/
    270              {
    271                  drop_mask = robot_wheel_drop_mask();
    272                  if(drop_mask & WHEEL_DROP_STATE_RIGHT)
    273                  {
    274                      self_test_result = 1;
    275                  }
    276                  else
    277                  {
    278                      self_test_result = 0;
    279                  }
    280                  break;
    281              }
    282              case CMD_REMOTE:         // 0xf0000012, /*TURE OR FALSE*/
    283              {
    284                break;
    285              }
    286              case CMD_BUOY_L:         // 0xf0000013, /*TURE OR FALSE*/
    287              {
    288                  break;
    289              }
    290              case CMD_BUOY_R:         // 0xf0000014, /*TURE OR FALSE*/
    291              {
    292                  break;
    293              }
    294              case CMD_BUOY_MIDDLE:
    295                  break;
    296              case CMD_BAT:            // 0xf0000015, /*BAT ADC VOL*/
    297              {
    298                  self_test_result = battery_voltage_average();
    299                  printf("CMD_BAT=%d\r\n",self_test_result);
    300                  tmp_value[0] = battery_voltage_average();
    301                  if((tmp_value[0] >= 3649/*3775*/) && (tmp_value[0] < 3954/*4090*/))
    302                  {
    303                      vram_read(ADJ_BAT_VOL_OFFSET, tmp_value, 2);
    304                     if((write_nvram_flag == 0)||(tmp_value[0] != 0x55aa))
    305                     {
    306                        write_nvram_flag = 1;
    307                        tmp_value[0] = 0x55aa;
    308                        //vram_write(0, &tmp_value, 1);
    309                        tmp_value[1] = battery_voltage_average();
    310                        vram_write(ADJ_BAT_VOL_OFFSET, tmp_value, 2);
    311                        songplayer_play_id(SONG_ID_BUTTON_CLICK, 0);
    312          
    313                     }
    314                     else
    315                     {
    316                        songplayer_play_id(SONG_ID_BUTTON_CLICK, 0);
    317                     }                           
    318                  }
    319                  break;
    320              }
    321              case CMD_TEMP:           // 0xf0000016, /*TEMP ADC */
    322              {
    323                  self_test_result = get_bat_temp();
    324                  //self_test_result = battery_temperature_average();
    325                  break;
    326              }
    327              case CMD_JACK_CHARGING:  // 0xf0000017, /*TURE OR FALSE*/
    328              {
    329                  self_test_result = charging_jack(); 
    330                  break;
    331              }
    332              case CMD_JACK_CURRENT:   // 0xf0000018, /*CURRENT*/
    333              {
    334                  self_test_result = charge_current_get(); 
    335                  break;
    336              }
    337              case CMD_DOCK_CHARGING:  // 0xf0000019, /*TURE OR FALSE*/
    338              {
    339                  self_test_result = charging_dock(); 
    340                  break;
    341              }
    342              case CMD_DOCK_CURRENT:   // 0xf000001a, /*CURRENT*/
    343              {
    344                  self_test_result = charge_current_get(); 
    345                  printf("CMD_DOCK_CURRENT=%d\r\n",self_test_result);
    346                  break;
    347              }
    348              case CMD_WHEEL_R_FORWARD:// 0xf000001B, /*CURRENT*/
    349              {
    350                  //if(!wheel_test_event)
    351                  {
    352                    wheel_test_event = 1;
    353                    set_motor_vels(0, 200, ACCELERATION_NON_EMERGENCY);
    354                  }
    355                  self_test_result = get_adc_chan_val(ADC_CHAN_RIGHT_MOTOR_CURRENT);
    356                  printf("CMD_WHEEL_R_FORWARD=%d\r\n",self_test_result);		
    357                  break;
    358              }
    359              case CMD_WHEEL_L_FORWARD:// 0xf000001C, /*CURRENT*/
    360              {
    361                  //if(!wheel_test_event)
    362                  {
    363                    wheel_test_event = 1;
    364                    set_motor_vels(200, 0, ACCELERATION_NON_EMERGENCY);
    365                  }
    366                  self_test_result = get_adc_chan_val(ADC_CHAN_LEFT_MOTOR_CURRENT);
    367                  printf("CMD_WHEEL_L_FORWARD=%d\r\n",self_test_result);		
    368                  break;
    369              }
    370              case CMD_WHEEL_R_REV_SPD:// 0xf000001D, /*speed*/
    371              {
    372                  //if(!wheel_test_event)
    373                  {
    374                    wheel_test_event = 1;
    375                    set_motor_vels(0, -200, ACCELERATION_NON_EMERGENCY);
    376                  }
    377                  self_test_result = 0; 
    378                  break;
    379              }
    380              case CMD_WHEEL_L_REV_SPD:// 0xf000001E, /*speed*/
    381              {
    382                  //if(!wheel_test_event)
    383                  {
    384                    wheel_test_event = 1;
    385                    set_motor_vels(-200, 0, ACCELERATION_NON_EMERGENCY);
    386                  }
    387                  self_test_result = 0; 
    388                  break;
    389              }
    390              case CMD_MAIN_FORWARD:   // 0xf000001f, /*CURRENT*/
    391              {
    392                  if (other_motor_test == 0)
    393                  {
    394          		  robot_midbrush_vols_set(1);
    395                    robot_mid_brush_adjust_set(MAIN_BRUSH_MAX_VOLTAGE);
    396                    other_motor_test = 1;
    397                  }
    398                  self_test_result = get_adc_chan_val(ADC_CHAN_MAIN_BRUSH_CURRENT);
    399                  printf("CMD_MAIN_FORWARD=%d\r\n",self_test_result);
    400                  break;
    401              }
    402              case CMD_MAIN_REV:       // 0xf0000020, /*CURRENT*/
    403              {
    404              	  if (other_motor_test == 0)
    405              	  {
    406          			robot_midbrush_vols_set(1);
    407                    robot_mid_brush_adjust_set(MAIN_BRUSH_MAX_VOLTAGE);
    408                    other_motor_test = 1; 
    409                  }
    410                  self_test_result = get_adc_chan_val(ADC_CHAN_MAIN_BRUSH_CURRENT);
    411                  printf("CMD_MAIN_REV=%d\r\n",self_test_result);
    412                  break;
    413              }
    414              case CMD_SIDE_FORWARD:   // 0xf0000021, /*CURRENT*/
    415              {
    416                  if (other_motor_test == 0)
    417                  {
    418          		  robot_sidebrush_vols_set(1);
    419                    robot_side_brush_adjust_set(SIDE_BRUSH_MAX_VOLTAGE);
    420                    other_motor_test = 1;
    421                  }
    422                  self_test_result = get_adc_chan_val(ADC_CHAN_SIDE_BRUSH_CURRENT);
    423                  printf("CMD_SIDE_FORWARD=%d\r\n",self_test_result);
    424                  break;
    425              }
    426              case CMD_SIDE_REV:       // 0xf0000022, /*CURRENT*/
    427              {
    428              	  if (other_motor_test == 0)
    429              	  {
    430          			robot_sidebrush_vols_set(1);
    431                    robot_side_brush_adjust_set(SIDE_BRUSH_MAX_VOLTAGE);
    432                    other_motor_test = 1;
    433                  }
    434                  self_test_result = 0; 
    435                  self_test_result = get_adc_chan_val(ADC_CHAN_SIDE_BRUSH_CURRENT);
    436                  printf("CMD_SIDE_REV=%d\r\n",self_test_result);
    437                  break;
    438              }
    439              case CMD_VACCUM:         // 0xf0000023, /*CURRENT*/
    440              {
    441              	  if (other_motor_test == 0)
    442              	  {
    443          			robot_suction_vols_set(1);
    444                    robot_suction_adjust_set(VACUUM_NORMAL_VOLTAGE);
    445                    other_motor_test = 1;
    446                    }	
    447                  self_test_result = get_adc_chan_val(ADC_CHAN_VAC_CURENT);
    448                  printf("CMD_VACCUM=%d\r\n",self_test_result);
    449                  break;
    450              }
    451              case CMD_BINFULL:        // 0xf0000024, /*TURE OR FALSE*/
    452              {
    453                  self_test_result = 0; 
    454                  break;
    455              }
    456              case CMD_DEBRIS:         // 0xf0000025, /*TURE OR FALSE*/
    457              {
    458                  self_test_result = 0; 
    459                  break;
    460              }
    461              case CMD_OPEN_ALL_LEDS:       // 0xf0000026,
    462              {
    463                  self_test_result = 0; 
    464                  break;
    465              }
    466              case CMD_UI_VERSION:      // 0xf0000027,
    467              {
    468          
    469          #ifdef GIT_VER_DEF
    470                  extern const char * GIT_SUB_VER;
    471                  printf( "%s \n",GIT_SUB_VER);
    472          #endif
    473                  //extern U8 g_software_version;
    474                  //self_test_result = g_software_version ;
    475                  break;
    476              }
    477              case CMD_WHEEL_SPEED:    // 0xf0000028,
    478              {
    479                  self_test_result = 0; 
    480                  break;
    481              }
    482              case CMD_GYRO:           // 0xf0000029,
    483              {
    484                self_test_result = gyro_is_ok();
    485                break;
    486              }
    487              case CMD_FLASH_SONG:     // 0xf000002a,
    488              {
    489          #if 0
    490                if (! ui_song_playing )
    491                {
    492                  ui_song_playing = 1;
    493                  songplayer_play_index(UI_MUSIC_ERROR_NOTIFY, FALSE);
    494                  while ( songplayer_is_playing() );
    495                  ui_song_playing = 0;
    496                }
    497          #endif
    498                self_test_result = 1; 
    499                break;
    500              }
    501              case CMD_UART:           // 0xf000002b,
    502              {
    503                  self_test_result = 0; 
    504                  break;
    505              }
    506              case CMD_LONGTEST:
    507              {
    508                  self_test_result = 2;
    509                  break;
    510              }
    511              case CMD_STASIS_TEST:
    512              {
    513                  if(!cmd_stasis_test)//第一次进来需要清除
    514                  {
    515                    cmd_stasis_test = 1;
    516                    robot_stasis_test_clear();
    517                  }
    518          
    519                  self_test_result = (robot_stasis_test_get());
    520                  if(self_test_result > 0)
    521                  {
    522                    test_result_dly = timer_ms();
    523                  }
    524          
    525                  if(timer_ms() - test_result_dly > 1000)
    526                  {
    527                    robot_stasis_test_clear();
    528                  }
    529                  break;
    530              }
    531              case CMD_TEST_ALL:
    532              {
    533                  /*
    534                if(!wheel_test_event)
    535                {
    536                    wheel_test_event = 1;
    537                    //start_motor_test(ALL_TEST,3000);
    538                }
    539                 other_motor_test = 1;
    540                 */
    541                 set_motor_vels(200, 200, ACCELERATION_NON_EMERGENCY);
    542          	   robot_suction_vols_set(1);
    543                 robot_suction_adjust_set(VACUUM_NORMAL_VOLTAGE); 
    544          	   robot_sidebrush_vols_set(1);
    545                 robot_side_brush_adjust_set(SIDE_BRUSH_MAX_VOLTAGE);
    546          	   robot_midbrush_vols_set(1);
    547                 robot_mid_brush_adjust_set(MAIN_BRUSH_MAX_VOLTAGE);
    548                 break;
    549              }
    550          
    551              case CMD_NULL:           // 0xf000002c
    552              {
    553                  self_test_result = 0; 
    554                  break;
    555              }
    556              case CMD_MASTER_VERSION:
    557              {
    558                  self_test_result = get_main_software_version() ;
    559              }
    560              break;
    561              case CMD_TEST_ALL_IR:
    562              {
    563                   ir_test_all_result();
    564              }
    565              break;
    566           extern   void SET_IR_STATE(U8 state);
    567              case CMD_TEST_BUMP_DROP:
    568              {
    569                SET_IR_STATE(1);
    570          //        self_test_result = 0;
    571          //        bump_state = get_bump_state();
    572          //        self_test_result = self_test_result|(((bump_state & BUMP_FRONT_LEFT)?1:0)<<4);
    573          //        self_test_result = self_test_result|(((bump_state & BUMP_FRONT_RIGHT)?1:0)<<3);
    574          //        self_test_result = self_test_result|(((bump_state & BUMP_FRONT_CENTER)?1:0)<<2);
    575          //
    576          //        drop_mask = robot_wheel_drop_mask();
    577          //        self_test_result = self_test_result|(((drop_mask & WHEEL_DROP_STATE_LEFT)?1:0)<<1);
    578          //        self_test_result = self_test_result|(((drop_mask & WHEEL_DROP_STATE_RIGHT)?1:0)<<0);
    579          //        printf("TEST_BUMP_DROP=%x\r\n",self_test_result);
    580          
    581              }
    582              break;
    583              case CMD_TEST_CLIFF_LIGHTTOUCH:
    584              {
    585                SET_IR_STATE(2);
    586          //        self_test_result = 0;
    587          //        self_test_result = self_test_result|robot_is_near_hazard(CLIFF_REAR_LEFT)<<11;
    588          //        self_test_result = self_test_result|robot_is_near_hazard(CLIFF_LEFT)<<10;
    589          //        self_test_result = self_test_result|robot_is_near_hazard(CLIFF_FRONTLEFT)<<9;
    590          //        self_test_result = self_test_result|robot_is_near_hazard(CLIFF_FRONTRIGHT)<<8;
    591          //        self_test_result = self_test_result|robot_is_near_hazard(CLIFF_RIGHT)<<7;
    592          //        self_test_result = self_test_result|robot_is_near_hazard(CLIFF_REAR_RIGHT)<<6;
    593          //        self_test_result = self_test_result|robot_is_near_wall(LT_LEFT)<<5;
    594          //        self_test_result = self_test_result|robot_is_near_wall(LT_CENTERLEFT)<<4;
    595          //        self_test_result = self_test_result|robot_is_near_wall(LT_FRONTLEFT)<<3;
    596          //        self_test_result = self_test_result|robot_is_near_wall(LT_FRONTRIGHT)<<2;
    597          //        self_test_result = self_test_result|robot_is_near_wall(LT_CENTERRIGHT)<<1;
    598          //        self_test_result = self_test_result|robot_is_near_wall(LT_RIGHT)<<0;
    599          //        printf("TEST_CLIFF_LIGHTTOUCH=%x\r\n",self_test_result);
    600              }
    601              break;
    602              case CMD_TEST_CLIFF_DROP_STASIS:
    603              {
    604                  if(!cmd_stasis_test)//第一次进来需要清除
    605                  {
    606                    cmd_stasis_test = 1;
    607                    robot_stasis_test_clear();
    608                  }
    609          
    610                  self_test_result = 0;
    611                  self_test_result = self_test_result|robot_is_near_hazard(CLIFF_LEFT)<<0;
    612                  self_test_result = self_test_result|robot_is_near_hazard(CLIFF_FRONTLEFT)<<1;
    613                  self_test_result = self_test_result|robot_is_near_hazard(CLIFF_FRONTRIGHT)<<2;
    614                  self_test_result = self_test_result|robot_is_near_hazard(CLIFF_RIGHT)<<3;
    615          
    616                  drop_mask = robot_wheel_drop_mask();
    617                  self_test_result = self_test_result|(((drop_mask & WHEEL_DROP_STATE_LEFT)?1:0)<<4);
    618                  self_test_result = self_test_result|(((drop_mask & WHEEL_DROP_STATE_RIGHT)?1:0)<<5);
    619          
    620                  stasis_state = ((robot_stasis_test_get())<<6);
    621                  self_test_result = self_test_result|stasis_state;
    622          
    623                  if(stasis_state > 0)
    624                  {
    625                      test_result_dly = timer_ms();
    626                  }
    627          
    628                  if(timer_ms() - test_result_dly > 1000)
    629                  {
    630                    robot_stasis_test_clear();
    631                  }
    632              }
    633              break;
    634              case CMD_TEST_LIGHTTOUCH_BUMP:
    635              {
    636                  self_test_result = 0;
    637                  bump_state = get_bump_state();
    638          
    639                  self_test_result = self_test_result|robot_is_near_wall(LT_LEFT)<<0;
    640                  self_test_result = self_test_result|robot_is_near_wall(LT_CENTERLEFT)<<1;
    641                  self_test_result = self_test_result|robot_is_near_wall(LT_FRONTLEFT)<<2;
    642                  self_test_result = self_test_result|robot_is_near_wall(LT_CENTERRIGHT)<<3;
    643                  self_test_result = self_test_result|robot_is_near_wall(LT_RIGHT)<<4;
    644                  self_test_result = self_test_result|(((bump_state & BUMP_FRONT_LEFT)?1:0)<<5);
    645                  self_test_result = self_test_result|(((bump_state & BUMP_FRONT_RIGHT)?1:0)<<6);
    646              }
    647              break;
    648              case CMD_TEST_WIRELESS:
    649              {
    650                   tmp_test_result = 0;
    651                   tmp_state = (U8)get_ir_test((IR_REMOT_POSITION_E)0);
    652          
    653          //         if(tmp_state == VW_BEACON_BYTE)
    654          //         {
    655          //            tmp_test_result |= 0x10;
    656          //         }
    657          
    658                   if(tmp_state == RIGHT_BEACON_BYTE)
    659                   {
    660                      tmp_test_result |= 0x04;
    661                   }
    662                   if(tmp_state == BOTH_BEACONS_BYTE)
    663                   {
    664                      tmp_test_result |= 0x02;
    665                   }
    666                   if(tmp_state == LEFT_BEACON_BYTE)
    667                   {
    668                      tmp_test_result |= 0x01;
    669                   }
    670                   if(tmp_test_result > 0)
    671                   {
    672                       self_test_result = tmp_test_result;
    673                       ui_test_last_ts = timer_ms();
    674                      // printf("self_test_result=%x\r\n",self_test_result);
    675                   }
    676                   else
    677                   {
    678                       if(timer_elapsed(ui_test_last_ts) > 600)
    679                       {
    680                          self_test_result = 0;
    681                       }
    682                   }
    683          
    684          
    685              }
    686              break;
    687              case CMD_TEST_MOVE_REVERSE:
    688              {
    689                /*  if(!wheel_test_event)
    690                {
    691                    wheel_test_event = 1;
    692          
    693                    //start_motor_test(ALL_TEST,-3000);
    694                }
    695                other_motor_test = 1;*/
    696                       set_motor_vels(-200, -200, ACCELERATION_NON_EMERGENCY);
    697          	   robot_suction_vols_set(1);
    698                 robot_suction_adjust_set(VACUUM_NORMAL_VOLTAGE);
    699          	   robot_sidebrush_vols_set(1);
    700                 robot_side_brush_adjust_set(SIDE_BRUSH_MAX_VOLTAGE);
    701          	   robot_midbrush_vols_set(1);
    702                 robot_mid_brush_adjust_set(MAIN_BRUSH_MAX_VOLTAGE);
    703              }
    704              break;
    705              case CMD_TEST_ALL_CHARGE_MODE:
    706              {
    707                  self_test_result = 0;
    708                  if(charging_jack())
    709                  {
    710                      self_test_result |= 0x40;
    711                  }
    712                  if(charging_dock())
    713                  {
    714                      self_test_result |= 0x01;
    715                  }
    716          
    717              }
    718              break;
    719              default:
    720                self_test_result = 0; break;
    721              }
    722              ui_test_num_last = cmd;
    723          }
    724          
    725          /****************************************************************
    726          *Function   :  ir_test_result
    727          *Description:  某个接收头是否接收到信号
    728          *Input      :  U8 nIrIndex:接收头ID           
    729          *Output     :  无
    730          *Return     :  无
    731          *Others     :  
    732          ******************************************************************/
    733          void ir_test_result(U8 nIrIndex)
    734          {
    735                U8 ir0 = (U8)get_ir_test((IR_REMOT_POSITION_E)nIrIndex) ;
    736                printf("ir0:%d,result:%d \r\n",ir0,self_test_result );
    737                if ( IS_BEACONS_BYTE(ir0) )
    738                {
    739                  self_test_result = 1;
    740                  ui_test_last_ts = timer_ms();
    741                }
    742                else
    743                {
    744                    self_test_result = (timer_elapsed(ui_test_last_ts) <= 1000) ;
    745                }
    746          }
    747          
    748          /****************************************************************
    749          *Function   :  ir_test_all_result
    750          *Description:  接收头是否接收到信号
    751          *Input      :  无           
    752          *Output     :  无
    753          *Return     :  无
    754          *Others     :  
    755          ******************************************************************/
    756          void ir_test_all_result(void)
    757          {
    758              U8 i;
    759              U8 tmp_ir_result=0;
    760              U8 ir0;
    761              self_test_result = 0;
    762              for(i=0;i<IR_DECODER_MAX;i++)
    763              {
    764                  ir0 = (U8)get_ir_test((IR_REMOT_POSITION_E)i) ;
    765                  printf("ir0:%d,result:%d \r\n",ir0,self_test_result );
    766                  if ( IS_BEACONS_BYTE(ir0) )
    767                  {
    768                      tmp_ir_result = 1;
    769                      ui_test_last_ts2[i] = timer_ms();
    770                  }
    771                  else
    772                  {
    773                      tmp_ir_result = (timer_elapsed(ui_test_last_ts2[i]) <= 500);
    774                      //self_test_result = (timer_elapsed(ui_test_last_ts) <= 1000) ;
    775                  }
    776                  self_test_result = ((self_test_result<<1)|tmp_ir_result);
    777          
    778              }
    779             // printf("ir_test_all_result=%x\r\n",self_test_result);
    780          
    781          }
    782          
    783          /****************************************************************
    784          *Function   :  get_test_result
    785          *Description:  获取测试结果
    786          *Input      :  无           
    787          *Output     :  无
    788          *Return     :  1:测试通过 0:测试不通过
    789          *Others     :  
    790          ******************************************************************/
    791          int get_test_result(void)
    792          {
    793            S16 left_m=0,left_s=0,right_m = 0,right_s=0;
    794            switch(ui_test_num_last)
    795            {
    796            	case CMD_BAT:
    797            		if (self_test_result >= CHARGING_CUTOFF_VOLTAGE && self_test_result <= CHARGING_MAXVOL)
    798            		{
    799            		  self_test_result = 1;
    800            		}
    801            		else
    802            		{
    803            		  self_test_result = 0;
    804            		}  
    805            		break;
    806            		
    807            	case CMD_DOCK_CURRENT:
    808            		if (self_test_result > 0 && self_test_result <= ADAPTER_OUTPUT_CURRENT)
    809            		{
    810            		  self_test_result = 1;
    811            		}
    812            		else
    813            		{
    814            		  self_test_result = 0;
    815            		} 
    816            	  break;
    817            	
    818            	case CMD_WHEEL_L_FORWARD:
    819            	case CMD_WHEEL_R_FORWARD:
    820            		if (self_test_result > 0 && self_test_result <= WHEEL_TWINE_CURRENT)
    821            		{
    822            		  self_test_result = 1;
    823            		}
    824            		else
    825            		{
    826            		  self_test_result = 0;
    827            		} 
    828            	  break;
    829            	  
    830            	case CMD_MAIN_FORWARD:  
    831            	case CMD_MAIN_REV:
    832            		if (self_test_result > 0 && self_test_result <= MAIN_BRUSH_TWINE_CURRENT)
    833            		{
    834            		  self_test_result = 1;
    835            		}
    836            		else
    837            		{
    838            		  self_test_result = 0;
    839            		} 
    840            	  break;
    841            	  
    842            	case CMD_SIDE_FORWARD:  
    843            	case CMD_SIDE_REV:
    844            		if (self_test_result > 0 && self_test_result <= SIDE_BRUSH_TWINE_CURRENT)
    845            		{
    846            		  self_test_result = 1;
    847            		}
    848            		else
    849            		{
    850            		  self_test_result = 0;
    851            		} 
    852            	  break;
    853            	case CMD_VACCUM:
    854          	  	 if(self_test_result > VACUUM_STALL_CURRENT)
    855          		  {
    856          				vac_current_over_count++;
    857          				if (vac_current_over_count > 300) 
    858          				{
    859          					self_test_result =0;
    860          				}
    861          				else
    862          				{
    863          					self_test_result =1;
    864          				}			
    865          		  }
    866          		 else 
    867          		 {
    868          			vac_current_over_count = 0;
    869          		  }	 
    870            	  break;  	      	
    871              case CMD_WHEEL_R_REV_SPD:// 0xf000001D, /*speed*/
    872              {
    873                get_motor_speeds(&left_m,&right_m);
    874                get_commanded_speeds(&left_s,&right_s);
    875                printf("left_m:%d,right_m:%d",left_m,right_m);
    876                printf("left_s:%d,right_s:%d\r\n",left_s,right_s);      
    877                printf("CMD_WHEEL_R_REV_SPD:%d\r\n",abs(right_m - right_s));
    878                self_test_result = abs(right_m - right_s)*100/abs(right_s) > 5 ? 0:1;
    879              }
    880              break;
    881              case CMD_WHEEL_L_REV_SPD:// 0xf000001E, /*speed*/
    882              {
    883                get_motor_speeds(&left_m,&right_m);
    884                get_commanded_speeds(&left_s,&right_s);
    885                printf("left_m:%d,right_m:%d",left_m,right_m);
    886                printf("left_s:%d,right_s:%d\r\n",left_s,right_s);
    887                printf("CMD_WHEEL_L_REV_SPD:%d\r\n",abs(left_m - left_s));
    888                self_test_result = abs(left_m - left_s)*100/abs(left_s) > 5 ? 0:1;      
    889              }
    890              break;
    891            case CMD_REMOTE:         // 0xf0000012, /*TURE OR FALSE*/
    892              {
    893                ir_test_result(0);
    894              }
    895                   break;
    896            case CMD_BUOY_L:
    897              ir_test_result(1);
    898              break;
    899            case CMD_BUOY_R:
    900              ir_test_result(2);
    901              break;
    902            case CMD_BUOY_MIDDLE:
    903               ir_test_result(3);
    904              break;
    905            }
    906            return self_test_result;
    907          }
    908          
    909          //#ifdef PC_AUTO_TEST
    910          #if 1
    911          
    912          #define AUTO_TEST_BUFFER_SIZE 80
    913          extern volatile s16 signal_delta[IR_SENSOR_NUM];
    914          
    915          extern volatile uint16_t main_brush_current;
    916          extern volatile uint16_t side_brush_current;
    917          extern volatile uint16_t left_motor_current;
    918          extern volatile uint16_t right_motor_current;
    919          extern volatile uint16_t battery_line_current;
    920          extern s32 signal_average_on[];
    921          extern s32 signal_average_off[];
    922          
    923          static const uint8_t modeAndVersion[20] = "XR510F VER 0107";
    924          
    925          
    926          extern void set_debug_uart_tx_fifo_empty_irq(void);
    927          extern u8 any_key(void);
    928          extern void ir_send_task_init(void);
    929          extern U32 get_key_val(void);
    930          extern U16 charging_jack(void);
    931          extern U16 charging_dock(void);
    932          extern u16 get_vaccum_current(void);
    933          extern s16 convert_to_current( s16 c_adc); 
    934          static volatile uint16_t auto_test_time_count = 0;
    935          static volatile uint16_t auto_test_receive_data = 0;
    936          static uint8_t auto_test_buf[AUTO_TEST_BUFFER_SIZE];
    937          static volatile uint8_t auto_test_sending_index = 0;
    938          static uint8_t auto_test_data_size = 0;
    939          static uint32_t last_key_val=0;
    940          static U32 pc_test_dly = 0;
    941          //static U8  write_nvram_flag = 0;
    942          static uint8_t key_press_cnt=0;
    943          
    944          int auto_test_tx_handle(void)
    945          {
    946            int retval = -1;
    947            if (auto_test_sending_index < auto_test_data_size) {
    948                retval = auto_test_buf[auto_test_sending_index];
    949                auto_test_sending_index++;     
    950            } else {
    951                auto_test_data_size = 0;
    952                auto_test_sending_index = 0;
    953                auto_test_receive_data = 0;
    954            }
    955             return retval;
    956          }
    957          
    958          int auto_test_rx_handle(int data)
    959          {
    960             auto_test_receive_data = ((auto_test_receive_data<<8) | (data&0x0FF));
    961             if (auto_test_receive_data == 0xAAAA) {
    962                 auto_test_time_count = 3000;
    963             }   
    964             return 0;
    965          }
    966          
    967          
    968            
    969          
    970          int send_auto_test_data(void)
    971          {
    972            uint8_t i;
    973          
    974            WheelDropState drop_mask ;
    975            uint16_t checksum;
    976            uint16_t temp_value;
    977            uint32_t tmp_value;
    978            uint32_t temp_value2[2];
    979            uint16_t temp_current;
    980            uint8_t tmp_state;
    981            uint32_t key_val = KEY_NULL;
    982               float a = TICKS_PER_MM;
    983            int16_t left_speed=0, right_speed = 0;
    984             get_motor_speeds(&left_speed,&right_speed);
    985           // robot_get_measured_speeds(&left_speed, &right_speed);
    986           
    987            //tmp_state = get_ir_test((IR_REMOT_POSITION_E)0);
    988          
    989            
    990            memset(auto_test_buf, 0, sizeof(auto_test_buf));
    991          
    992            if((timer_ms() - pc_test_dly > 2500)&&(ui_test_cmd != 0))
    993            {
    994               if(ui_test_cmd == CMD_TEST_ALL)
    995               {
    996                  ui_test_cmd = CMD_TEST_MOVE_REVERSE;
    997               }
    998               else if(ui_test_cmd == CMD_TEST_MOVE_REVERSE)
    999               {
   1000                  ui_test_cmd = CMD_TEST_ALL;
   1001               }
   1002               pc_test_dly = timer_ms();
   1003            }
   1004            auto_test_buf[0] = 0xAA;
   1005            //左边地检
   1006            temp_value = signal_delta[CLIFF_LEFT];
   1007            auto_test_buf[1] = (uint8_t)(temp_value>>8);
   1008            auto_test_buf[2] = (uint8_t)(temp_value>>0);
   1009            //左中地检
   1010            temp_value = signal_delta[CLIFF_FRONTLEFT];
   1011            auto_test_buf[3] = (uint8_t)(temp_value>>8);
   1012            auto_test_buf[4] = (uint8_t)(temp_value>>0);
   1013            //右中地检
   1014            temp_value = signal_delta[CLIFF_FRONTRIGHT];
   1015            auto_test_buf[5] = (uint8_t)(temp_value>>8);
   1016            auto_test_buf[6] = (uint8_t)(temp_value>>0);
   1017            //右边地检
   1018            temp_value = signal_delta[CLIFF_RIGHT];
   1019            auto_test_buf[7] = (uint8_t)(temp_value>>8);
   1020            auto_test_buf[8] = (uint8_t)(temp_value>>0);
   1021              
   1022            //左边墙检
   1023            temp_value = signal_delta[LT_LEFT];
   1024            auto_test_buf[9] = (uint8_t)(temp_value>>8);
   1025            auto_test_buf[10] = (uint8_t)(temp_value>>0);
   1026            
   1027            //左中墙检
   1028            temp_value = signal_delta[LT_CENTERLEFT];
   1029            auto_test_buf[11] = (uint8_t)(temp_value>>8);
   1030            auto_test_buf[12] = (uint8_t)(temp_value>>0);
   1031            
   1032            //中间墙检
   1033            temp_value = signal_delta[LT_FRONTLEFT];
   1034            auto_test_buf[13] = (uint8_t)(temp_value>>8);
   1035            auto_test_buf[14] = (uint8_t)(temp_value>>0);  
   1036            //右中墙检
   1037            temp_value = signal_delta[LT_CENTERRIGHT];
   1038            auto_test_buf[15] = (uint8_t)(temp_value>>8);
   1039            auto_test_buf[16] = (uint8_t)(temp_value>>0);  
   1040            //右边墙检
   1041            temp_value = signal_delta[LT_RIGHT];
   1042            auto_test_buf[17] = (uint8_t)(temp_value>>8);
   1043            auto_test_buf[18] = (uint8_t)(temp_value>>0); 
   1044            
   1045            //红外发射 4byte
   1046            auto_test_buf[19] = get_ir_test((IR_REMOT_POSITION_E)0);
   1047            auto_test_buf[20] = get_ir_test((IR_REMOT_POSITION_E)1);
   1048            auto_test_buf[21] = get_ir_test((IR_REMOT_POSITION_E)2);
   1049            auto_test_buf[22] = get_ir_test((IR_REMOT_POSITION_E)3);
   1050            
   1051            //左轮电流
   1052            tmp_value = get_adc_chan_val(ADC_CHAN_LEFT_MOTOR_CURRENT);
   1053            //tmp_value = tmp_value*926/1862/10;
   1054            auto_test_buf[23] = (uint8_t)(tmp_value>>8);
   1055            auto_test_buf[24] = (uint8_t)(tmp_value>>0); 
   1056            
   1057            //左轮速度
   1058            left_speed = abs(left_speed)/(int16_t)a;
   1059            auto_test_buf[25] = (uint8_t)(left_speed>>8);
   1060            auto_test_buf[26] = (uint8_t)(left_speed>>0);
   1061            
   1062            //右轮电流
   1063            tmp_value = get_adc_chan_val(ADC_CHAN_RIGHT_MOTOR_CURRENT);
   1064            //tmp_value = tmp_value*926/1862/10;
   1065            auto_test_buf[27] = (uint8_t)(tmp_value>>8);
   1066            auto_test_buf[28] = (uint8_t)(tmp_value>>0); 
   1067            
   1068            //右轮速度
   1069            right_speed = abs(right_speed)/(int16_t)a;
   1070            auto_test_buf[29] = (uint8_t)(right_speed>>8);
   1071            auto_test_buf[30] = (uint8_t)(right_speed>>0);
   1072            
   1073            //中扫电流
   1074            tmp_value = get_adc_chan_val(ADC_CHAN_MAIN_BRUSH_CURRENT);
   1075            //tmp_value = tmp_value*926/1862/10;
   1076            auto_test_buf[31] = (uint8_t)(tmp_value>>8);
   1077            auto_test_buf[32] = (uint8_t)(tmp_value>>0);
   1078            
   1079            //灰尘盒电流
   1080            tmp_value = get_adc_chan_val(ADC_CHAN_VAC_CURENT);
   1081            //tmp_value = tmp_value*1000/4096*33/10;
   1082            auto_test_buf[33] = (uint8_t)(tmp_value>>8);
   1083            auto_test_buf[34] = (uint8_t)(tmp_value>>0);
   1084            
   1085            //充电电流
   1086            if(charging_state_get() > 0)
   1087            {
   1088                //temp_value =  hal_analog_input_get(HAL_ADC_BATTERY_CURRENT);
   1089                temp_current = charge_current_get();
   1090                //printf("temp_current=%d\r\n",temp_current);
   1091                if(temp_current < 0)
   1092                {
   1093                   temp_current = 0;
   1094                }
   1095            }
   1096            else
   1097            {
   1098                temp_current = 0;
   1099            }
   1100            
   1101            auto_test_buf[35] = (uint8_t)(temp_current>>8);
   1102            auto_test_buf[36] = (uint8_t)(temp_current>>0);  
   1103            
   1104            //电池电压
   1105            //temp_value = hal_analog_input_get(HAL_ADC_BATTERY_VOLTAGE);
   1106            //校准电压 
   1107            temp_value2[0] = battery_voltage_average();
   1108            if((temp_value2[0] >= 3649/*3775*/) && (temp_value2[0] < 3954/*4090*/))
   1109            {
   1110               vram_read(ADJ_BAT_VOL_OFFSET, temp_value2, 2);
   1111               if((write_nvram_flag == 0)||(temp_value2[0] != 0x55aa))
   1112               {
   1113                  write_nvram_flag = 1;
   1114                  temp_value2[0] = 0x55aa;
   1115                 // vram_write(0, &tmp_value, 1);
   1116                  temp_value2[1] = battery_voltage_average();
   1117                  vram_write(ADJ_BAT_VOL_OFFSET, temp_value2, 2);
   1118                  songplayer_play_id(SONG_ID_BUTTON_CLICK, 0);
   1119          
   1120               }
   1121               else
   1122               {
   1123                  songplayer_play_id(SONG_ID_BUTTON_CLICK, 0);
   1124               }                           
   1125            }
   1126            
   1127            tmp_value = battery_voltage_average();
   1128            tmp_value = ((tmp_value*330000/174)>>12)*10;
   1129            auto_test_buf[37] = (uint8_t)(tmp_value>>8);
   1130            auto_test_buf[38] = (uint8_t)(tmp_value>>0);
   1131            
   1132            //电池温度 1byte
   1133            //temp_value = hal_analog_input_get(HAL_ADC_BATTERY_THERMISTOR);
   1134            //auto_test_buf[39] = (uint8_t)(temp_value>>8);
   1135             auto_test_buf[39] = 55;
   1136            //机器型号 1byte
   1137            auto_test_buf[40] = 0x01;
   1138            
   1139            //机器软件版本 2byte
   1140            //temp_value = g_software_version;
   1141            temp_value = 817;
   1142            auto_test_buf[41] = (uint8_t)(temp_value>>8);
   1143            auto_test_buf[42] = (uint8_t)(temp_value>>0);
   1144            
   1145            //错误代码 1byte
   1146            //auto_test_buf[43] = ui_error_number;
   1147            auto_test_buf[43] = 0;
   1148            /*
   1149            //扩展内容 5byte
   1150            auto_test_buf[44] = 0xAA;
   1151            auto_test_buf[45] = 0xAA;
   1152            auto_test_buf[46] = 0xAA;
   1153            auto_test_buf[47] = 0xAA;
   1154            auto_test_buf[48] = 0xAA;
   1155            */
   1156            auto_test_buf[44] = 0x00;
   1157            //左轮方向
   1158            {
   1159              if( ui_test_cmd == CMD_TEST_MOVE_REVERSE)
   1160              {
   1161                  auto_test_buf[44] |= 0x80;
   1162              }
   1163            }
   1164            //右轮方向
   1165            {
   1166              if( ui_test_cmd == CMD_TEST_MOVE_REVERSE)
   1167              {
   1168                  auto_test_buf[44] |= 0x40;
   1169              }
   1170            }  
   1171            //中扫方向
   1172            {
   1173              auto_test_buf[44] |= 0x00;
   1174            }  
   1175            //左边地检
   1176            {
   1177              if(!robot_is_near_hazard(CLIFF_LEFT))
   1178              {
   1179                 auto_test_buf[44] |= 0x10;
   1180              }
   1181          
   1182            }
   1183            //左中地检
   1184            {
   1185              if(!robot_is_near_hazard(CLIFF_FRONTLEFT))
   1186              {
   1187                  auto_test_buf[44] |= 0x08;
   1188              }
   1189          
   1190            }  
   1191            //右中地检
   1192            {
   1193              if(!robot_is_near_hazard(CLIFF_FRONTRIGHT))
   1194              {
   1195                  auto_test_buf[44] |= 0x04;
   1196              }
   1197          
   1198            }  
   1199            //右边地检
   1200            {
   1201              if(!robot_is_near_hazard(CLIFF_RIGHT))
   1202              {
   1203                  auto_test_buf[44] |= 0x02;
   1204              }
   1205            }
   1206            //左边按键
   1207            {
   1208              
   1209             // key_val = get_key_val();
   1210              if(any_key())
   1211              {
   1212                  if(pc_test_dly == 0)
   1213                  {
   1214                      
   1215                      pc_test_dly = timer_ms();
   1216                  }
   1217                  if((timer_ms() - pc_test_dly)> 1000)
   1218                  {
   1219                      if(++key_press_cnt >= 4)
   1220                      {
   1221                          if(ui_test_cmd == 0)
   1222                          {
   1223                              ui_test_cmd = CMD_TEST_ALL;
   1224                              pc_test_dly = timer_ms();
   1225                          
   1226                          }
   1227                      }
   1228                  }
   1229                  else
   1230                  {
   1231                      //if(key_val > 0)
   1232                        //  key_press_cnt = 0;
   1233                  }
   1234              }
   1235          
   1236              //last_key_val = key_val;
   1237             // if(key_val & KEY_CLEAN) 
   1238             if(any_key())
   1239              {
   1240                  auto_test_buf[44] |= 0x01;
   1241              }
   1242              
   1243              
   1244            }  
   1245            auto_test_buf[45] = 0x00;
   1246            //中间按键
   1247            {
   1248              if(key_val & KEY_DOCK)
   1249              {
   1250                  auto_test_buf[45] |= 0x80;
   1251              }
   1252            }  
   1253            //右边按键
   1254            {
   1255              if(key_val & KEY_SPOT)
   1256          	{
   1257                  auto_test_buf[45] |= 0x40;
   1258              }
   1259            }
   1260            //左边墙检
   1261            {
   1262              if(robot_is_near_wall(LT_LEFT))
   1263              {
   1264                  auto_test_buf[45] |= 0x20;
   1265              }
   1266            }
   1267            //左中墙检
   1268            {
   1269              if(robot_is_near_wall(LT_CENTERLEFT))
   1270              {
   1271                  auto_test_buf[45] |= 0x10;
   1272              }
   1273            }
   1274            //中间墙检
   1275            {
   1276              if(robot_is_near_wall(LT_FRONTLEFT))
   1277              {
   1278                  auto_test_buf[45] |= 0x08;
   1279              }
   1280            }
   1281            //右中墙检
   1282            {
   1283              if(robot_is_near_wall(LT_CENTERRIGHT))
   1284              {
   1285                  auto_test_buf[45] |= 0x04;
   1286              }
   1287            }
   1288            //右边墙检
   1289            {
   1290              if(robot_is_near_wall(LT_RIGHT))
   1291              {
   1292                  auto_test_buf[45] |= 0x02;
   1293              }
   1294            }
   1295            //万向轮
   1296            {
   1297                  if(!cmd_stasis_test)//第一次进来需要清除
   1298                  {
   1299                    cmd_stasis_test = 1;
   1300                    robot_stasis_test_clear();
   1301                  }
   1302                  
   1303                  self_test_result = (robot_stasis_test_get()); 
   1304                  if(self_test_result > 0)
   1305                  {
   1306                      
   1307                    test_result_dly = timer_ms();
   1308                  }
   1309                  
   1310                  if(timer_ms() - test_result_dly > 1000)
   1311                  {
   1312                    robot_stasis_test_clear();
   1313                  }
   1314                  if(self_test_result > 0)
   1315                  {
   1316                      auto_test_buf[45] |= 0x01;
   1317                  }
   1318            }
   1319          
   1320            auto_test_buf[46] = 0x00;
   1321            //左边碰撞
   1322            {
   1323              bump_state = get_bump_state();
   1324              if(bump_state == BUMP_FRONT_LEFT)
   1325              {
   1326                  auto_test_buf[46] |= 0x80;
   1327              }
   1328            }  
   1329            //右边碰撞
   1330            {
   1331              if(bump_state == BUMP_FRONT_RIGHT)
   1332              {
   1333                  auto_test_buf[46] |= 0x40;
   1334              }
   1335            }
   1336            
   1337            //左边红外
   1338            {
   1339             
   1340              {
   1341                 auto_test_buf[46] |= 0x00;
   1342              }
   1343            }
   1344            
   1345            //前面红外
   1346            {
   1347              
   1348              if(tmp_state > 0)
   1349              {
   1350                  auto_test_buf[46] |= 0x10;
   1351              }
   1352            }
   1353            //顶上红外
   1354            {
   1355              if(tmp_state > 0)
   1356              {
   1357                  auto_test_buf[46] |= 0x08;
   1358              }
   1359            }
   1360            //右边红外
   1361            {
   1362              auto_test_buf[46] |= 0x00;
   1363            }  
   1364            //左边离地
   1365            {
   1366              drop_mask = robot_wheel_drop_mask();
   1367              if(drop_mask & WHEEL_DROP_STATE_LEFT)
   1368              {
   1369                  auto_test_buf[46] |= 0x02;
   1370              }
   1371            }
   1372            //右边离地
   1373            {
   1374              if(drop_mask & WHEEL_DROP_STATE_RIGHT)
   1375              {
   1376                  auto_test_buf[46] |= 0x01;
   1377              }
   1378            }
   1379            
   1380            //边扫电流
   1381            auto_test_buf[47] = 0x00;
   1382            {
   1383              //if(side_brush_current>10)
   1384                //  printf("side_brush_current=%d\r\n",side_brush_current);
   1385              if(side_brush_current >= SIDE_BRUSH_TWINE_CURRENT)
   1386              {
   1387                  
   1388                  auto_test_buf[47] |= 0x08;
   1389              }
   1390             //if(main_brush_current>10)
   1391               //   printf("main_brush_current=%d\r\n",main_brush_current);
   1392             if(main_brush_current >= MAIN_BRUSH_TWINE_CURRENT)
   1393              {
   1394                  auto_test_buf[47] |= 0x04;
   1395              }
   1396           
   1397              
   1398            }
   1399           //  auto_test_buf[47] |= 0x04;
   1400            //座充
   1401            {
   1402              if(charging_dock())
   1403              {
   1404                  auto_test_buf[47] |= 0x02;
   1405              }
   1406            }
   1407            //直充
   1408            {
   1409              if(charging_jack())
   1410              {
   1411                  auto_test_buf[47] |= 0x01;
   1412              }
   1413            }
   1414            
   1415            checksum = 0;
   1416            for (i=0; i<48; i++) {
   1417              checksum += auto_test_buf[i];
   1418            }
   1419            auto_test_buf[48] = (uint8_t)checksum;
   1420            
   1421            auto_test_buf[49] = 'x';
   1422            auto_test_buf[50] = 'r';
   1423            auto_test_buf[51] = 'o';
   1424            auto_test_buf[52] = 'b';
   1425            auto_test_buf[53] = 'o';
   1426            auto_test_buf[54] = 't';
   1427            
   1428            for (i=0; i<15; i++) {
   1429              auto_test_buf[55+i] = modeAndVersion[i];
   1430              if (modeAndVersion[i] == '\0') {
   1431                break;
   1432              }
   1433            }
   1434            auto_test_buf[55+i] = '\0';
   1435          
   1436            tmp_value = side_brush_current;
   1437            //tmp_value = tmp_value*926/1862/10;
   1438            auto_test_buf[55+i+1] = (uint8_t)(tmp_value>>8);
   1439            auto_test_buf[55+i+2] = (uint8_t)(tmp_value>>0);
   1440            auto_test_buf[55+i+3] = (uint8_t)get_ir_test((IR_REMOT_POSITION_E)4);
   1441            auto_test_buf[55+i+4] = (uint8_t)get_ir_test((IR_REMOT_POSITION_E)5);
   1442            i+=4;
   1443            auto_test_data_size = 55+i+1;  
   1444            auto_test_sending_index = 0;
   1445            set_debug_uart_tx_fifo_empty_irq();
   1446            return 0;
   1447          }
   1448          #endif
   1449          
   1450          
   1451          /****************************************************************
   1452          *Function   :  set_adjust_adc_value_to_system
   1453          *Description:  回写电压校准的参数到系统
   1454          *Input      :  无           
   1455          *Output     :  无
   1456          *Return     :  无
   1457          *Others     :  
   1458          ******************************************************************/
   1459          void set_adjust_adc_value_to_system(void)
   1460          {
   1461              uint32_t tmp_value[2];
   1462          
   1463              vram_read(ADJ_BAT_VOL_OFFSET, tmp_value, 2);
   1464              if(tmp_value[0] == 0x55aa)
   1465              {
   1466                  //vram_read(2, &tmp_value, 1);
   1467                  printf("set adc value:%d\r\n",tmp_value[1]);
   1468                  robot_set_adc_adjust((uint16_t)tmp_value[1]);
   1469              }
   1470              
   1471          }
   1472          
   1473          /****************************************************************
   1474          *Function   :  self_test_routine
   1475          *Description:  处理测试模式
   1476          *Input      :  无           
   1477          *Output     :  无
   1478          *Return     :  无
   1479          *Others     :  
   1480          ******************************************************************/
   1481          void self_test_routine(void)
   1482          {
   1483            if (ui_test_cmd != CMD_TEST_WAIT)
   1484            {
   1485              handle_test_cmd(ui_test_cmd);
   1486            }
   1487            /*
   1488            if (auto_test_time_count == 0) {
   1489                 debug_uart_register_tx_handle(auto_test_tx_handle);
   1490                 debug_uart_register_rx_handle(auto_test_rx_handle);
   1491              } else if (auto_test_time_count == 300){
   1492                 debug_uart_reset();
   1493              }
   1494              */
   1495             if (auto_test_time_count < 300) {
   1496                auto_test_time_count++;
   1497              }
   1498          
   1499             if (auto_test_receive_data == 0xAAAA) 
   1500             {
   1501            
   1502                  if((pc_test_enableq == 0)&&(pc_test_dly == 0))
   1503                  {
   1504                      //write_nvram_flag = 0;
   1505                      pc_test_dly = timer_ms();            
   1506                  }
   1507                  if((timer_ms() - pc_test_dly > 100)&&(pc_test_enableq == 0))
   1508                  {
   1509          
   1510                      robot_sensor_gather_start(1);
   1511                      last_key_val=0;
   1512                      pc_test_dly = 0;
   1513                      key_press_cnt=0;
   1514                      pc_test_enableq = 1;
   1515          			pc_test_flag = 1;
   1516                      set_ui_state(UI_TEST);
   1517          
   1518                  }
   1519                  if ((auto_test_sending_index >= auto_test_data_size)) {
   1520                      send_auto_test_data();
   1521                  }
   1522              }
   1523              
   1524          }
   1525          
   1526          U8 get_pc_test_flag(void)
   1527          {
   1528              return pc_test_enableq;
   1529          }
   1530          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   auto_test_rx_handle
       0   auto_test_tx_handle
       8   get_bat_temp
         8   -> __aeabi_f2iz
         8   -> battery_temperature_get
       0   get_pc_test_flag
      32   get_test_result
        32   -- Indirect call
        32   -> abs
        32   -> get_commanded_speeds
        32   -> get_motor_speeds
        32   -> ir_test_result
      40   handle_test_cmd
        40   -- Indirect call
        40   -> SET_IR_STATE
        40   -> battery_voltage_average
        40   -> charge_current_get
        40   -> charging_dock
        40   -> charging_jack
        40   -> get_adc_chan_val
        40   -> get_bat_temp
        40   -> get_bump_state
        40   -> get_ir_test
        40   -> get_main_software_version
        40   -> gyro_is_ok
        40   -> ir_test_all_result
        40   -> robot_is_cliff
        40   -> robot_is_lighttouch
        40   -> robot_mid_brush_adjust_set
        40   -> robot_midbrush_vols_set
        40   -> robot_side_brush_adjust_set
        40   -> robot_sidebrush_vols_set
        40   -> robot_stasis_test_clear
        40   -> robot_stasis_test_get
        40   -> robot_suction_adjust_set
        40   -> robot_suction_vols_set
        40   -> robot_wheel_drop_mask
        40   -> set_motor_vels
        40   -> songplayer_play_id
        40   -> timer_elapsed
        40   -> timer_ms
        40   -> vram_read
        40   -> vram_write
      32   ir_test_all_result
        32   -- Indirect call
        32   -> get_ir_test
        32   -> timer_elapsed
        32   -> timer_ms
      16   ir_test_result
        16   -- Indirect call
        16   -> get_ir_test
        16   -> timer_elapsed
        16   -> timer_ms
      16   robot_bump_mask
        16   -- Indirect call
      16   robot_wheel_drop_mask
        16   -- Indirect call
       8   self_test_routine
         8   -> handle_test_cmd
         8   -> robot_sensor_gather_start
         8   -> send_auto_test_data
         8   -> set_ui_state
         8   -> timer_ms
      40   send_auto_test_data
        40   -> __aeabi_memclr4
        40   -> abs
        40   -> any_key
        40   -> battery_voltage_average
        40   -> charge_current_get
        40   -> charging_dock
        40   -> charging_jack
        40   -> charging_state_get
        40   -> get_adc_chan_val
        40   -> get_bump_state
        40   -> get_ir_test
        40   -> get_motor_speeds
        40   -> robot_is_cliff
        40   -> robot_is_lighttouch
        40   -> robot_stasis_test_clear
        40   -> robot_stasis_test_get
        40   -> robot_wheel_drop_mask
        40   -> set_debug_uart_tx_fifo_empty_irq
        40   -> songplayer_play_id
        40   -> timer_ms
        40   -> vram_read
        40   -> vram_write
      16   set_adjust_adc_value_to_system
        16   -- Indirect call
        16   -> robot_set_adc_adjust
        16   -> vram_read


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       4  ??DataTable27_5
       4  ??DataTable27_6
       4  ??DataTable27_7
      12  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
      10  ?Subroutine3
       8  ?Subroutine4
      12  ?Subroutine5
      12  ?Subroutine6
      16  ?Subroutine7
      16  ?Subroutine8
      16  ?_0
      24  ?_1
      24  ?_10
      24  ?_11
      28  ?_12
      28  ?_13
      20  ?_14
      28  ?_2
      28  ?_3
      24  ?_4
      20  ?_5
      24  ?_6
      20  ?_7
      16  ?_8
      20  ?_9
      80  auto_test_buf
      34  auto_test_rx_handle
      42  auto_test_tx_handle
      56  bump_state
          wheel_test_event
          other_motor_test
          cmd_stasis_test
          write_nvram_flag
          pc_test_enableq
          pc_test_flag
          auto_test_sending_index
          auto_test_data_size
          key_press_cnt
          ui_test_num_last
          vac_current_over_count
          auto_test_time_count
          auto_test_receive_data
          self_test_result
          ui_test_last_ts
          test_result_dly
          ui_test_last_ts2
          pc_test_dly
      50  get_bat_temp
       6  get_pc_test_flag
     388  get_test_result
    1334  handle_test_cmd
     106  ir_test_all_result
      76  ir_test_result
       4  last_key_val
      20  modeAndVersion
      32  robot_bump_mask
      32  robot_wheel_drop_mask
     114  self_test_routine
    1150  send_auto_test_data
      42  set_adjust_adc_value_to_system
       4  stasis_state
      20  temp_list
      60  test_item_table

 
   144 bytes in section .bss
    60 bytes in section .data
 3 920 bytes in section .text
 
 3 920 bytes of CODE memory
   204 bytes of DATA memory

Errors: none
Warnings: 3
